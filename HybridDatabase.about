Hybridní databáze
-----------------

Hybridní databáze je objektovou databází, která se snaží kombinovat persistenci
a transakční přístup klasických (relačních) databází s rychlostí a a ovladatelností
datových struktur. Data jsou organizována do uzlů, každý uzel má typ z množiny
pevné pro konkrétní databázi.

Každý uzel je složen z atributů. Atributy obsahují
vlastní data a jejich typy jsou následující - celá čísla o 8 až 64 bitech
s i bez znaménka -- Int8 až Int64, unsigned verze mají předponu U (tedy char až 
long long plus unsigned verze v C), reálná čísla
(Float, Double, LDouble, tedy float, double, long double v C).

String je C-like textový řetězec, RawString má na rozdíl od Stringu uloženou i délku
takže může obsahovat '\0'. Posledním typem je Pointer, což je ukazatel na jiný
uzel (v paměti realizován jako Node*, na disku jako id uzlu, na který odkazuje).


-------------------
-  Základní typy  -
-------------------

Node - předek libovolného uzlu, obsahuje id, počítadlo referencí (uzel nelze
       smazat, ukazuje-li na něj jiný uzel) a ukazatel na deskriptor popisující typ
       uzlu (NodeType*) - tento ukazatel je prvním prvek v Node

     - podtřídy jsou definovány jako:

  typedef struct {
    Node __ancestor;

    atributy toho uzlu
  } MyNode;

  extern const NodeType MyNode_desc;

Handler - pomocný objekt pro práci s databází, jeho prostřednictvím se 
          spouštějí transakce
Database - třída představující databázi jako celek
  - od obou vznikají podtřídy při genrování databáze s konkrétními typy uzlů
    a indexy. K Database se přitom přídávájí kontexty indexů (tedy jejich privátní
    data). Od Handler se potřídy vyrábějí pouze pro zachování typové informace
    o databázi (což je nutné pro přístup k indexům).

  typedef struct {
    Database __database;

    struct {
      deskriptory typů uzlů
    } node_types;

    struct {
      indexy (objekty typu *_handler_t)
    } indexes;
  } PokusnáDatabáze;

  typedef union {  
    Database *database;
    MyDatabase *my_database;
    Handler __ancestor;
  } MyDatabse_handler_t;


---------------------------------
-  Výroba typů uzlů a databáze  -
---------------------------------

Typy uzlů, indexů a databází se definují podle následující gramatiky:

soubor := (interface | implementation | node_type | index_type | database_type | comment)*

comment := '#' /[^\n]*/
interface := 'Interface' block
implementation := 'Implementation' block

node_type := 'NodeType' název_typu ':' C_typ '{' attribute* '}'
attribute := 'Attribute' název_atributu ':' typ_attributu

index_type := 'IndexType' název ':' typ_kontextu '{' init? destroy? update method* '}'
init := 'Init' (block | function)
destroy := 'Destroy' (block | function)
update := 'Update' (block | function)
method := 'Method' jméno_metody args? ':' return_type block

database_type := 'DatabaseType' jméno '{' (node | index)* '}'
node := 'NodeType' typu_uzlu
index := 'Index' jméno 'for' (typ_uzlu | 'all') ':' typ_indexu

args := '(' /[^)]*/ ')'
block := '@' /[^@]*/ '@'
function := 'function' jméno_funkce

Z takového souboru se pomocí skriptu generate/generate.pl vygeneruje C kód.
(Skript bere 4 parametry:
  1. slovo, které se vloží do #ifndef na začátku generovaného hlavičkového souboru
  2. 1 nebo 0, jestli se má/nemá generovat rozhraní
  3. 1 nebo 0, jestli se má/nemá generovat implementace
  4. cokoli co se vyhodnotí jako true, pokud skript nemá vypisovat ladicí hlášky
)
Skript vždy čte standardní vstup a zapisuje na standardní výstup.
Všechny interface sekce se zkonkatenují a vloží na začátek vygenerovaného rozhraní.
Sekce implementation se vloží na začátek implementace.


----------------------
-  Implementace STM  -
----------------------

STM je implementována pomocí verzovaných zámků a globálních hodin. Užívá
undo log, neboť redo log by bylo obtížné implementovat tak, aby transakce
viděla změny, které sama provedla. To by ovšem znamenalo velké obtíže
při implementaci indexů (ty jsou taky v STM).


----------------------
-  Průběh transakce  -
----------------------

1) zahajení transakce - tr_begin(H) (nebo makro trBegin)
2) v průběhu transakce se čtené hodnoty poznamenávají
   do read-setu (H->read_set) a modifikace do H->log (je typu FastStack)
3) při commitu se:
  a) získá globalní zámek H->database->mutex
  b) zkontroluje read-set, zda nebyla čtená data modifikována jinou transakcí
  c) transakce přidá do fronty k zapsání na disk (H->database->output.tail)
     (froonta je jednosměrný spoják)
  d) odemkne H->database->mutex
  e) zvýší semafor H->database->output.counter
  f) je-li transakce synchronní, počká se na zprávu od servisního
     vlákna o dokončení zápisu


---------------------
-  Servisní vlákno  -
--------------------

Definováno v database.include/treads.c, čte položky z fronty (database->output.head) a
zapisuje obsah na disk, případně uvolňuje paměť, která ma být uvolněna.
Kromě zápisu standardních transakcí, ještě obsluhuje vytvářření nových souborů,
vypsání databáze a také udržuje spoják všech Nodů (aby je byo možné všechny vypsat
či uvolnit).

