Hybridní databáze
-----------------

Hybridní databáze je objektovou databází, která se snaží kombinovat persistenci
a transakční přístup klasických (relačních) databází s rychlostí a a ovladatelností
datových struktur. Data jsou organizována do uzlů, každý uzel má typ z množiny
pevné pro konkrétní databázi.

Každý uzel je složen z atributů. Atributy obsahují
vlastní data a jejich typy jsou následující - celá čísla o 8 až 64 bitech
s i bez znaménka -- Int8 až Int64, unsigned verze mají předponu U (tedy char až 
long long plus unsigned verze v C), reálná čísla
(Float, Double, LDouble, tedy float, double, long double v C).

String je C-like textový řetězec, RawString má na rozdíl od Stringu uloženou i délku
takže může obsahovat '\0'. Posledním typem je Pointer, což je ukazatel na jiný
uzel (v paměti realizován jako Node*, na disku jako id uzlu, na který odkazuje).


------------------
  Základní typy:
------------------

Node - předek libovolného uzlu, obsahuje id, počítadlo referencí (uzel nelze
       smazat, ukazuje-li na něj jiný uzel) a ukazatel na deskriptor popisující typ
       uzlu (NodeType*) - tento ukazatel je prvním prvek v Node

     - podtřídy jsou definovány jako:

  typedef struct {
    Node __ancestor;

    atributy toho uzlu
  } MyNode;

  extern const NodeType MyNode_desc;

Handler - pomocný objekt pro práci s databází, jeho prostřednictvím se 
          spouštějí transakce
Database - třída představující databázi jako celek
  - od obou vznikají podtřídy při genrování databáze s konkrétními typy uzlů
    a indexy. K Database se přitom přídávájí kontexty indexů (tedy jejich privátní
    data). Od Handler se potřídy vyrábějí pouze pro zachování typové informace
    o databázi (což je nutné pro přístup k indexům).

  typedef struct {
    Database __database;

    struct {
      deskriptory typů uzlů
    } node_types;

    struct {
      indexy (objekty typu *_handler_t)
    } indexes;
  } PokusnáDatabáze;

  typedef union {  
    Database *database;
    MyDatabase *my_database;
    Handler __ancestor;
  } MyDatabse_handler_t;


--------------
  Interface:
--------------

// Vytvoří objekt třídy Database a načte přísloušnou databázi z disku
// (či vytvoří prázdnou, neexistuje-li)
Database *database_create(DatabaseType* type, const char* dir, const char* file, unsigned int flags);

int database_close(Database* D);

// znovu vypsání databáz na disk
int database_dump(Database* D, int sync);

// počká na dokončení výpisu databáze na disk
void database_wait_for_dump(Database *D);

// začne zapisovat do dalšího souboru
int database_new_file(Database* D);


// započne hlavní transakci (tedy takovou, která při commitu skutečně data zapíše)
Transaction* tr_main_start(Database*);
void tr_main_abort(Transaction*);
int tr_main_commit(Transaction*, int sync);

// započne vnořenou transakci podřízenou dané hlavní transakci
void tr_start(Transaction*);
void tr_abort(Transaction*);
void tr_commit(Transaction*);


Node *node_create_(Transaction*, NodeType*);
int node_remove(Transaction*, Node*);

#define NodeCreate(Typ)
#define DatabaseCreate(Typ)
#define NodeCast(Typ, uzel)

#define TrUncast(transakce)
#define TrDBUncast(databáze)
#define TrNodeUncast(uzel)

#define NodeCast(Typ, uzel)

Vyjma database_create a node_create_ jsou všechny tyto funkce vlastně makra,
která je mapují na funkce stejného jména s _ na konci. Přidanou hodnotou maker
je, že provádí bezpečné přetypování z podtříd daných objektů na vyžadované
nadtřídy (pomocí maker TrUncast, TrDBUncast a TrNodeUncast).

Pro database_create a node_create_ exsistují makra DatabaseCreate a NodeCreate,
která jako parametr berou jméno typu vytvářeného objektu.

Pro uzly existuje ještě funkce NodeCast(Typ, uzel), která daný uzel přetypuje
na Typ (při neúspěchu vrací NULL).


#define TrRead(uzel, Atribut)
#define TrWrite(uzel, Atribut, hodnota)
#define TrVerify(uzel)

#define TrRead_(transakce, uzel, Atribut, VýstupníProměnná)
#define TrWrite_(transakce, uzel, Atribut, hodnota)
#define TrVerify_(transakce, uzel)

K atributům uzlu se přistupuje pomocí maker TrRead(uzel, Atribut)
a TrWrite(uzel, Atribut, hodnota). Nebo je možné číst atributy přímo
pomocí uzel->Atribut a až na závěr ověřit korektrnost dat pomocí
TrVerify(uzel). K těmto makrů existují i verze zakončené _, které berou navíc
jako první parametr transakci (místo defaultní _transaction)
a místo vyvolání vyjímky při chybě vrací 0.
(TrRead_ tedy nemůže načtenou hodnotu přímo vracet a má tedy jako poslední
parametr jméno proměnné, do níž hodnotu uloží.)


Pro indexy existují makra pro přístup k paměti zamykané po blocích (8 bytech).
Tyto je nutné používat pro všechnu transakční paměť nenáležející uzlům.

#define TrBlockRead(ptr)
#define TrBlockWrite(ptr, hodnota)
#define TrBlockVerify(ptr)

K nim existují příslušné varianty s _ na konci. Velikost dat se vypočítává
pomocí typu daného ukazatele.

Pro pohodlnou práci s transakcemi existují nasledující makra (která navíc
oproti funkcím, na nichž staví, uživají výjimky):

#define TrMainStart(databáze)
#define TrMainAbort
#define TrMainCommit(synchronní)

#define TrStart
#define TrAbort
#define TrCommit

Tato makra (vždy Start a Commit) se chovají jako závorky. Abort zruší probíhající
transakci. TrMainAbort se od TrAbort liší tím, že neruší pouze nejhoubeji vnořenou
transakci, ale celou hlavní transakci. Vnitřně užívají vyjímky TR_FAIL,
TR_MAIN_ABORT a TR_ABORT. Pokud tranakce selže s výjimku TR_FAIL, je automaticky
restartována. Pokud selhává opakovaně je restartována po uplynutí časové prodlevy.


---------------------------------
-  Výroba typů uzlů a databáze  -
---------------------------------

Typy uzlů, indexů a databází se definují podle následující gramatiky:

soubor := (interface | implementation | node_type | index_type | database_type | comment)*

comment := '#' /[^\n]*/
interface := 'Interface' block
implementation := 'Implementation' block

node_type := 'NodeType' název_typu ':' C_typ '{' attribute* '}'
attribute := 'Attribute' název_atributu ':' typ_attributu

index_type := 'IndexType' název ':' typ_kontextu '{' init? destroy? update method* '}'
init := 'Init' (block | function)
destroy := 'Destroy' (block | function)
update := 'Update' (block | function)
method := 'Method' jméno_metody '=' function

database_type := 'DatabaseType' jméno '{' (node | index)* '}'
node := 'NodeType' typu_uzlu
index := 'Index' jméno 'for' (typ_uzlu | 'all') ':' typ_indexu

block := '@' /[^@]*/ '@'
function := 'function' jméno_funkce

Z takového souboru se pomocí skriptu generate/generate.pl vygeneruje C kód.
(Skript bere 4 parametry:
  1. slovo, které se vloží do #ifndef na začátku generovaného hlavičkového souboru
  2. 1 nebo 0, jestli se má/nemá generovat rozhraní
  3. 1 nebo 0, jestli se má/nemá generovat implementace
  4. cokoli co se vyhodnotí jako true, pokud skript nemá vypisovat ladicí hlášky
)
Skript vždy čte standardní vstup a zapisuje na standardní výstup.
Všechny interface sekce se zkonkatenují a vloží na začátek vygenerovaného rozhraní.
Sekce implementation se vloží na začátek implementace.

----------------------
-  Implementace STM  -
----------------------

STM je implementována pomocí verzovaných zámků a globálních hodin. Užívá
undo log, neboť redo log by bylo obtížné implementovat tak, aby transakce
viděla změny, které sama provedla. To by ovšem znamenalo velké obtíže
při implementaci indexů (ty jsou taky v STM).





------------------------
-  Stack & Dictionary  -
------------------------

Implementace datových struktur zásobník a "slovník" -- tedy hash tabulka
ukládající dvojice klíč - hodnota. Obě jsou implementovány jako sada maker.
Díky tomu stejná makra pracují nad příslušnými strukturami bez ohledu na v nich
uložený typ.


---------------------
-  Reader & Writer  -
---------------------

V souboru storge.h je jednoduché rozhraní pro zápis, čtení strukturovaných
souborů (datové typy -- pole a string). Nepracují přímo se soubory. Writer
zapisuje do bufferu v paměti a funkcemi w_ptr a w_length se dá získat jeho
adresa a délka. Reader pak při vytvoření požaduje funkci a pointer, který
jí bude předávat jako kontext. Ji pak volá, potřebuje-li načíst další data.




