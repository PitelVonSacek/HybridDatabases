Hybridní databáze
-----------------

Hybridní databáze je objektovou databází, která se snaží kombinovat persistenci
a transakční přístup klasických (relačních) databází s rychlostí a a ovladatelností
datových struktur. Data jsou organizována do uzlů, každý uzel má typ z množiny
pevné pro konkrétní databázi.

Každý uzel je složen z atributů. Atributy obsahují
vlastní data a jejich typy jsou následující - celá čísla o 8 až 64 bitech
s i bez znaménka -- Int8 až Int64, unsigned verze mají předponu U (tedy char až 
long long plus unsigned verze v C), reálná čísla
(Float, Double, LDouble, tedy float, double, long double v C).

String je C-like textový řetězec, RawString má na rozdíl od Stringu uloženou i délku
takže může obsahovat '\0'. Posledním typem je Pointer, což je ukazatel na jiný
uzel (v paměti realizován jako Node*, na disku jako id uzlu, na který odkazuje).


-------------------
-  Základní typy  -
-------------------

Node - předek libovolného uzlu, obsahuje id, počítadlo referencí (uzel nelze
       smazat, ukazuje-li na něj jiný uzel) a ukazatel na deskriptor popisující typ
       uzlu (NodeType*) - tento ukazatel je prvním prvek v Node

     - podtřídy jsou definovány jako:

  typedef struct {
    Node __ancestor;

    atributy toho uzlu
  } MyNode;

  extern const NodeType MyNode_desc;

Handler - pomocný objekt pro práci s databází, jeho prostřednictvím se 
          spouštějí transakce
Database - třída představující databázi jako celek
  - od obou vznikají podtřídy při genrování databáze s konkrétními typy uzlů
    a indexy. K Database se přitom přídávájí kontexty indexů (tedy jejich privátní
    data). Od Handler se potřídy vyrábějí pouze pro zachování typové informace
    o databázi (což je nutné pro přístup k indexům).

  typedef struct {
    Database __database;

    struct {
      deskriptory typů uzlů
    } node_types;

    struct {
      indexy (objekty typu *_handler_t)
    } indexes;
  } PokusnáDatabáze;

  typedef union {  
    Database *database;
    MyDatabase *my_database;
    Handler __ancestor;
  } MyDatabse_handler_t;


---------------------------------
-  Výroba typů uzlů a databáze  -
---------------------------------

Typy uzlů, indexů a databází se definují podle následující gramatiky:

soubor := (interface | implementation | node_type | index_type | database_type | comment)*

comment := '#' /[^\n]*/
interface := 'Interface' block
implementation := 'Implementation' block

node_type := 'NodeType' název_typu ':' C_typ '{' attribute* '}'
attribute := 'Attribute' název_atributu ':' typ_attributu

index_type := 'IndexType' název ':' typ_kontextu '{' init? destroy? update method* '}'
init := 'Init' (block | function)
destroy := 'Destroy' (block | function)
update := 'Update' (block | function)
method := 'Method' jméno_metody args? ':' return_type block

database_type := 'DatabaseType' jméno '{' (node | index)* '}'
node := 'NodeType' typu_uzlu
index := 'Index' jméno 'for' (typ_uzlu | 'all') ':' typ_indexu

args := '(' /[^)]*/ ')'
block := '@' /[^@]*/ '@'
function := 'function' jméno_funkce

Z takového souboru se pomocí skriptu generate/generate.pl vygeneruje C kód.
(Skript bere 4 parametry:
  1. slovo, které se vloží do #ifndef na začátku generovaného hlavičkového souboru
  2. 1 nebo 0, jestli se má/nemá generovat rozhraní
  3. 1 nebo 0, jestli se má/nemá generovat implementace
  4. cokoli co se vyhodnotí jako true, pokud skript nemá vypisovat ladicí hlášky
)
Skript vždy čte standardní vstup a zapisuje na standardní výstup.
Všechny interface sekce se zkonkatenují a vloží na začátek vygenerovaného rozhraní.
Sekce implementation se vloží na začátek implementace.


----------------------
-  Implementace STM  -
----------------------

STM je implementována pomocí verzovaných zámků a globálních hodin. Užívá
undo log, neboť redo log by bylo obtížné implementovat tak, aby transakce
viděla změny, které sama provedla. To by ovšem znamenalo velké obtíže
při implementaci indexů (ty jsou taky v STM).


----------------------
-  Průběh transakce  -
----------------------

1) zahajení transakce - tr_begin(H) (nebo makro trBegin)
2) v průběhu transakce se čtené (trRead, trIndex) hodnoty poznamenávají
   do read-setu (H->read_set) a modifikace (trWrite, trUpdateIndexes) do H->log 
   (je typu FastStack)
3) při commitu (tr_commit nebo trCommit) se:
  a) získá globalní zámek H->database->mutex
  b) zkontroluje read-set, zda nebyla čtená data modifikována jinou transakcí
  c) transakce přidá do fronty k zapsání na disk (H->database->output.tail)
     (froonta je jednosměrný spoják)
  d) odemkne H->database->mutex
  e) zvýší semafor H->database->output.counter
  f) je-li transakce synchronní, počká se na zprávu od servisního
     vlákna o dokončení zápisu

Pozn.: Indexy se neupdatují samy, ale na upravené uzly je nutné zavolat
       trUpdateIndexes (nebo tr_update_indexes). Tento postup byl zvolen,
       jelikož má nižší overhead (pokud se dělá více úprav jenoho uzlu),
       dovoluje uživateli lépe kontrolovat, kdy jsou/nejsou indexy konzistentí
       se stavem databáze a hlavně umožňuje uživateli definovat, že při
       updatu indexů budou uzly v nějakém konzistentním stavu.
       (Výše uvedené platí jen pro monofikace uzlů, při jejich tvorbě / mazání,
       jsou indexy updatovány automaticky a ihned)

---------------------
-  Servisní vlákno  -
---------------------

Definováno v database.include/treads.c, čte položky z fronty (database->output.head) a
zapisuje obsah na disk, případně uvolňuje paměť, která ma být uvolněna.
Kromě zápisu standardních transakcí, ještě obsluhuje vytváření nových souborů,
vypsání databáze a také udržuje spoják všech Nodů (aby je byo možné všechny vypsat
či uvolnit).


---------------
-  Alokátory  -
---------------

Node allocator - alokátor pro stejně velké objekty, je využíván pro alokaci
uzlů (jak jméno napovídá), ale i bloků FastStacku. Vnitřně udržuje spoják
uvolněných uzlů, z kterého uspokojuje nové požadavky. Pracuje bez zámků pomocí
atomických instrukcí. Pravděpodobně je velmi žádoucí vylepšit ho, aby nealokoval
mallocem jednotlivé položky, ale větší bloky, z nich by jednotlivé položky
vyráběl sám. (Což by, krom úspory paměti z hlaviček mallocu u každého bloku,
mohlo pomoi odstranit položku __list z definice Node.)

Generic allocator - alokátor pro paměť libovolné velikosti. Je nutný především
pro alokaci řetězců uložených v databázi. V současné době je to pouze slupka,
alloc se překládá na malloc a uvolněná paměť se strká do spojáku. 
?? Jak se dělá obecný alokátor ??

Oba alokátory při uvolňování paměti, krom bloku samotného přebírájí i čas
uvolnění, který slouží k tomu, aby paměť neuvolnili ve chvíli, kdy na ni
ještě nějaká transakce může mít pointer.

V současné době jsou užívány tak, že paměť neuvolňuje, je v plánu implementovat 
zprávu DB_SERVICE__COLLECT_GARBAGE servisnímu vláknu, která zajistí uvolnění
přebytečné paměti a pravděpodobně by byl vhodný i nějaký automatický mechanismus.
(třebe limit na počet volných bloků?)


