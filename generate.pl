#!/usr/bin/perl

use strict;
use warnings;

use Parse::RecDescent;
use feature "switch";
use Data::Dumper;

my $interface = 1;
my $implementation = 1;

our %node_types = ();
our %database_types = ();
our %index_types = ();
our @include = ();

$Parse::RecDescent::skip = '(\s|;)*';

my $grammar = q{
  { my @current = (); my %current = () }

  root: (node_type | index_type | database_type | include)(s?) 
 
  include: 'Include' /"[^"]*"/
    { push @::include, $item[2]; }

  node_type: 'NodeType' name '{' node_attribute(s?) '}'
    { $::node_types{$item{name}} = [ @current ]; @current = () }
  node_attribute: 'Attribute' name ':' type
    { push @current, [ $item{name}, $item{type} ] }

  database_type: 'DatabaseType' name '{' (node|index)(s?) '}'
    { $::database_types{$item{name}} = { %current }; %current = () }
  node:  'Node'  name 
    { push @{$current{node_types}}, $item{name} }
  index: 'Index' name ':' type 
    { push @{$current{index_types}}, $item{name} }

  index_type: 'IndexType' name '{' context '}'
    { $::index_types{$item{name}} = { %current }; %current = () }
  context: 'ContextType' c_type
    { $current{context_type} = $item{c_type} }

  name: identifier   { $item[1] }
  type: identifier   { $item[1] }
  c_type: /((struct|enum|union)\\s+)?\\w+/   { $item[1] }
  identifier: /\\w+/ { $item[1] }
};

my $parser = new Parse::RecDescent($grammar) or die "Error\n";
my @input = <>;
my $input = join(" ", @input);
$parser->root($input);

# print Dumper(\%node_types);
# print Dumper(\%database_types);
# print Dumper(\%index_types);

# print Dumper(\@include);

print <<'EOF';
/*
 * This file is generated by generate.pl
 * Don't edit this file
 */

#include ""

EOF

if ($interface) { for my $node_type (keys %node_types) {
  my @attrs = @{$node_types{$node_type}};

  print <<EOF;
typedef struct {
  Node __ancestor;

EOF

  for my $attr (@attrs) {
    print "  ${$attr}[1]_t ${$attr}[0];\n";
  }

  print <<EOF;
} $node_type;

extern const NodeType ${node_type}_desc;

EOF
}}

sub node_type_mk_fce {
  my ($fce, $args_long, $args, $node_type, $attrs_) = @_;
  my @attrs = @{$attrs_};

  print "static void ${node_type}_$fce($args_long) {\n";

  for my $attr (@attrs) {
    print "  attribute_${fce}_${$attr}[1]($args &node->${$attr}[0]);\n";
  }

  print "}\n\n";
};

if ($implementation) { for my $node_type (keys %node_types) {
  my @attrs = @{$node_types{$node_type}};

  # FIXME $#attrs == -1 when @attrs empty
  print "static const struct NodeAttribute ${node_type}_desc_attributes[$#attrs + 1] = {\n";

  my $i = 0;
  for my $attr (@attrs) {
    print <<EOF;
  { 
    .name = "${$attr}[0]",
    .type = ${$attr}[1],
    .index = $i,
    .offset = __builtin_offsetof($node_type, ${$attr}[0])
  },
EOF
    $i++;
  }

  print "  {}\n};\n\n";

  # load
  print "static bool ${node_type}_load(Reader *R, struct " .
        "GenericAllocatorInfo *allocator, $node_type *node) {\n" .
        "  if (\n";

  for my $attr (@attrs) {
    print "    !attribute_load_${$attr}[1](R, allocator, &node->${$attr}[0]) ||\n";
  }
   
  print "    false\n  ) return false;\n" .
        "  return true;\n}\n\n";

  # init_pointers
  print "static bool ${node_type}_init_pointers(IdToNode *nodes, $node_type *node) {\n";

  for my $attr (@attrs) {
    print "  node->${$attr}[0].value.value = node->${$attr}[0].value.id ? \n" .
          "    ndict_at(nodes, node->${$attr}[0].value.id) : 0;\n"
      if ${$attr}[1] eq "Pointer";
  }
   
  print "}\n\n";

  # destroy_pointers
  print "static bool ${node_type}_destroy_pointers(Handler *H, $node_type *node) {\n" .
        "  const void *zero = 0;\n" .
        "  if (\n";

  # FIXME
  for my $attr (@attrs) {
    print "    !attribute_write_$node_type(H, end_time, &node->${$attr}[0], &zero) ||\n" 
      if ${$attr}[1] eq "Pointer";
  }
   
  print "    false;\n  ) return false;\n  return true;\n}\n\n";

  node_type_mk_fce("store", "Writer *W, $node_type *node,", "W,", 
                   $node_type, \@attrs);
  
  node_type_mk_fce("init", "$node_type *node", "", 
                   $node_type, \@attrs);
  
  node_type_mk_fce("destroy",
    "struct GenericAllocatorInfo *a, $node_type *node, uint64_t end_time", "a, end_time,", 
                   $node_type, \@attrs);

  print <<EOF;
const NodeType ${node_type}_desc = {
  .name = "$node_type",

  .load = (bool(*)(Reader*, struct GenericAllocatorInfo*, Node*)&${node_type}_load,
  .store = (void(*)(Writer*, Node*))&${node_type}_store,

  .init_pointers = (void(*)(IdToNode*, Node*))&${node_type}_init_pointers,
  .destroy_pointers = (int(*)(Handler*, Node*))&${node_type}_destroy_pointers,

  .init = (void(*)(Node*))&${node_type}_init,
  .destroy = (void(*)(struct GenericAllocatorInfo*, Node*, uint64_t))&${node_type}_destroy,

  { sizeof($node_type), 0, 0 },

  .update_indexes = 0,

  .size = sizeof($node_type),
  .extra_space = 0,
  .id = 0,

  .attributes_count = $#attrs,
  .attributes = ${node_type}_desc_attributes;
};

EOF
}}


